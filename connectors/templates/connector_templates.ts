/**
 * Connector Templates for klaus-kode-agentic-integrator
 *
 * These templates provide the foundation for AI-generated connectors
 * between different types of applications in the ecosystem.
 */

import { ApplicationType, ConnectionProtocol } from '../core/connector_framework';

/**
 * Template for Node.js TypeScript to Node.js TypeScript connectors
 */
export const NODEJS_TO_NODEJS_TEMPLATE = `
/**
 * Connector: {{SOURCE_APP}} â†’ {{TARGET_APP}}
 * Generated by klaus-kode-agentic-integrator
 */

import { RestApiConnector, WebSocketConnector, ConnectionProtocol } from '../core/connector_framework';
import WebSocket from 'ws';

export class {{SOURCE_APP}}To{{TARGET_APP}}Connector {
  private restConnector?: RestApiConnector;
  private wsConnector?: WebSocketConnector;
  private config: any;

  constructor(config: any = {}) {
    this.config = {
      sourceApp: '{{SOURCE_APP}}',
      targetApp: '{{TARGET_APP}}',
      protocols: [ConnectionProtocol.REST_API, ConnectionProtocol.WEBSOCKET],
      baseUrl: process.env.{{TARGET_APP}}_URL || 'http://localhost:{{TARGET_PORT}}',
      wsUrl: process.env.{{TARGET_APP}}_WS_URL || 'ws://localhost:{{TARGET_WS_PORT}}',
      apiKey: process.env.{{TARGET_APP}}_API_KEY,
      ...config
    };
  }

  async connect(): Promise<void> {
    // Initialize REST API connector
    this.restConnector = new RestApiConnector(
      this.config.sourceApp,
      this.config.targetApp,
      this.config.baseUrl,
      this.config.apiKey
    );

    // Initialize WebSocket connector for real-time features
    this.wsConnector = new WebSocketConnector(
      this.config.sourceApp,
      this.config.targetApp,
      this.config.wsUrl
    );

    // Connect both connectors
    await Promise.all([
      this.restConnector.connect(),
      this.wsConnector.connect()
    ]);

    console.log(\`âœ… Connected {{SOURCE_APP}} â†’ {{TARGET_APP}}\`);
  }

  async disconnect(): Promise<void> {
    await Promise.all([
      this.restConnector?.disconnect(),
      this.wsConnector?.disconnect()
    ]);

    console.log(\`âœ… Disconnected {{SOURCE_APP}} â†’ {{TARGET_APP}}\`);
  }

  async healthCheck(): Promise<any> {
    const [restHealth, wsHealth] = await Promise.all([
      this.restConnector?.healthCheck(),
      this.wsConnector?.healthCheck()
    ]);

    return {
      rest: restHealth,
      websocket: wsHealth,
      overall: (restHealth?.status === 'healthy' && wsHealth?.status === 'healthy') ? 'healthy' : 'degraded'
    };
  }

  async sendData(data: any): Promise<void> {
    // Use REST for structured data, WebSocket for real-time updates
    if (data.type === 'realtime') {
      await this.wsConnector?.sendData(data);
    } else {
      await this.restConnector?.sendData(data);
    }
  }

  async receiveData(handler: (data: any) => void): Promise<void> {
    // Set up data handlers for both protocols
    this.restConnector?.on('dataReceived', handler);
    this.wsConnector?.on('dataReceived', handler);
  }
}
`;

/**
 * Template for Python Streamlit to Node.js connectors
 */
export const PYTHON_TO_NODEJS_TEMPLATE = `
/**
 * Connector: {{SOURCE_APP}} â†’ {{TARGET_APP}}
 * Python Streamlit to Node.js bridge
 * Generated by klaus-kode-agentic-integrator
 */

import { RestApiConnector, ConnectionProtocol } from '../core/connector_framework';
import { spawn } from 'child_process';
import path from 'path';

export class {{SOURCE_APP}}To{{TARGET_APP}}Connector {
  private restConnector?: RestApiConnector;
  private pythonProcess?: any;
  private config: any;

  constructor(config: any = {}) {
    this.config = {
      sourceApp: '{{SOURCE_APP}}',
      targetApp: '{{TARGET_APP}}',
      pythonScript: path.join(process.cwd(), '..', '{{SOURCE_APP}}', 'main.py'),
      baseUrl: process.env.{{TARGET_APP}}_URL || 'http://localhost:{{TARGET_PORT}}',
      ...config
    };
  }

  async connect(): Promise<void> {
    // Start Python Streamlit process if not running
    await this.startPythonProcess();

    // Initialize REST API connector for Node.js target
    this.restConnector = new RestApiConnector(
      this.config.sourceApp,
      this.config.targetApp,
      this.config.baseUrl
    );

    await this.restConnector.connect();

    console.log(\`âœ… Connected {{SOURCE_APP}} â†’ {{TARGET_APP}}\`);
  }

  async disconnect(): Promise<void> {
    // Stop Python process
    if (this.pythonProcess) {
      this.pythonProcess.kill();
    }

    await this.restConnector?.disconnect();

    console.log(\`âœ… Disconnected {{SOURCE_APP}} â†’ {{TARGET_APP}}\`);
  }

  private async startPythonProcess(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.pythonProcess = spawn('python', [this.config.pythonScript], {
        cwd: path.dirname(this.config.pythonScript),
        stdio: ['pipe', 'pipe', 'pipe']
      });

      this.pythonProcess.stdout.on('data', (data: Buffer) => {
        console.log(\`{{SOURCE_APP}} stdout:\`, data.toString());
      });

      this.pythonProcess.stderr.on('data', (data: Buffer) => {
        console.error(\`{{SOURCE_APP}} stderr:\`, data.toString());
      });

      this.pythonProcess.on('close', (code: number) => {
        console.log(\`{{SOURCE_APP}} process exited with code \${code}\`);
      });

      // Wait for process to be ready
      setTimeout(() => {
        resolve();
      }, 2000);
    });
  }

  async sendData(data: any): Promise<void> {
    // Send data to Python process via REST API
    await this.restConnector?.sendData({
      source: this.config.sourceApp,
      data: data,
      timestamp: new Date().toISOString()
    });
  }

  async receiveData(handler: (data: any) => void): Promise<void> {
    this.restConnector?.on('dataReceived', handler);
  }
}
`;

/**
 * Template for React frontend connectors
 */
export const REACT_FRONTEND_TEMPLATE = `
/**
 * Connector Template for React Frontend Applications
 * Generated by klaus-kode-agentic-integrator
 */

import React, { useState, useEffect, useCallback } from 'react';
import { ApplicationConnector, ConnectionProtocol } from '../core/connector_framework';

interface {{COMPONENT_NAME}}Props {
  targetApp: string;
  onDataReceived?: (data: any) => void;
  onConnectionChange?: (connected: boolean) => void;
}

export const {{COMPONENT_NAME}}: React.FC<{{COMPONENT_NAME}}Props> = ({
  targetApp,
  onDataReceived,
  onConnectionChange
}) => {
  const [connector, setConnector] = useState<ApplicationConnector | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<string>('disconnected');

  const handleConnect = useCallback(async () => {
    try {
      if (!connector) {
        // Initialize connector based on target application
        const newConnector = new ApplicationConnector(
          'ReactFrontend',
          targetApp
        );

        newConnector.on('connected', () => {
          setIsConnected(true);
          setConnectionStatus('connected');
          onConnectionChange?.(true);
        });

        newConnector.on('disconnected', () => {
          setIsConnected(false);
          setConnectionStatus('disconnected');
          onConnectionChange?.(false);
        });

        newConnector.on('dataReceived', (data: any) => {
          onDataReceived?.(data);
        });

        setConnector(newConnector);
      }

      if (!isConnected) {
        await connector.connect();
      }
    } catch (error) {
      console.error('Connection failed:', error);
      setConnectionStatus('error');
    }
  }, [connector, isConnected, targetApp, onDataReceived, onConnectionChange]);

  const handleDisconnect = useCallback(async () => {
    try {
      await connector?.disconnect();
    } catch (error) {
      console.error('Disconnection failed:', error);
    }
  }, [connector]);

  useEffect(() => {
    // Auto-connect on mount if needed
    handleConnect();

    // Cleanup on unmount
    return () => {
      handleDisconnect();
    };
  }, [handleConnect, handleDisconnect]);

  return (
    <div className="connector-widget">
      <div className="connection-status">
        <span className={\`status-indicator \${connectionStatus}\`}></span>
        <span className="status-text">
          {connectionStatus === 'connected' ? 'ðŸŸ¢ Connected' :
           connectionStatus === 'disconnected' ? 'ðŸ”´ Disconnected' :
           connectionStatus === 'error' ? 'ðŸŸ¡ Error' : 'ðŸŸ  Connecting...'}
        </span>
      </div>

      <div className="connection-controls">
        {!isConnected ? (
          <button onClick={handleConnect} className="connect-btn">
            Connect to {targetApp}
          </button>
        ) : (
          <button onClick={handleDisconnect} className="disconnect-btn">
            Disconnect
          </button>
        )}
      </div>
    </div>
  );
};
`;

/**
 * Template for Web3/blockchain connectors
 */
export const WEB3_CONNECTOR_TEMPLATE = `
/**
 * Web3 Connector Template
 * Generated by klaus-kode-agentic-integrator
 */

import { ethers } from 'ethers';
import { RestApiConnector, ConnectionProtocol } from '../core/connector_framework';

export class {{SOURCE_APP}}ToBlockchainConnector {
  private provider?: ethers.Provider;
  private restConnector?: RestApiConnector;
  private contract?: ethers.Contract;
  private config: any;

  constructor(config: any = {}) {
    this.config = {
      sourceApp: '{{SOURCE_APP}}',
      blockchainNetwork: 'ethereum',
      contractAddress: process.env.CONTRACT_ADDRESS,
      rpcUrl: process.env.RPC_URL || 'https://mainnet.infura.io/v3/YOUR_PROJECT_ID',
      baseUrl: process.env.{{TARGET_APP}}_URL || 'http://localhost:{{TARGET_PORT}}',
      ...config
    };
  }

  async connect(): Promise<void> {
    // Initialize blockchain connection
    this.provider = new ethers.JsonRpcProvider(this.config.rpcUrl);

    // Initialize smart contract if address provided
    if (this.config.contractAddress) {
      // Contract ABI would be loaded from compiled contracts
      // this.contract = new ethers.Contract(address, abi, this.provider);
    }

    // Initialize REST connector for off-chain data
    this.restConnector = new RestApiConnector(
      this.config.sourceApp,
      'Blockchain',
      this.config.baseUrl
    );

    await this.restConnector.connect();

    console.log(\`âœ… Connected {{SOURCE_APP}} â†’ Blockchain\`);
  }

  async disconnect(): Promise<void> {
    await this.restConnector?.disconnect();
    console.log(\`âœ… Disconnected {{SOURCE_APP}} â†’ Blockchain\`);
  }

  async sendTransaction(data: any): Promise<string> {
    if (!this.provider) {
      throw new Error('Provider not initialized');
    }

    // Create and send transaction
    const signer = await this.provider.getSigner();
    const tx = await signer.sendTransaction({
      to: data.to,
      value: data.value,
      data: data.data
    });

    return tx.hash;
  }

  async queryBlockchain(query: any): Promise<any> {
    if (!this.provider) {
      throw new Error('Provider not initialized');
    }

    // Perform blockchain queries
    const blockNumber = await this.provider.getBlockNumber();
    return { blockNumber, query };
  }
}
`;

/**
 * Template registry for connector generation
 */
export class ConnectorTemplateRegistry {
  private templates: Map<string, string> = new Map();

  constructor() {
    this.registerTemplates();
  }

  private registerTemplates(): void {
    this.templates.set('nodejs_nodejs', NODEJS_TO_NODEJS_TEMPLATE);
    this.templates.set('python_nodejs', PYTHON_TO_NODEJS_TEMPLATE);
    this.templates.set('react_frontend', REACT_FRONTEND_TEMPLATE);
    this.templates.set('web3_connector', WEB3_CONNECTOR_TEMPLATE);
  }

  getTemplate(sourceType: ApplicationType, targetType: ApplicationType): string | null {
    const key = \`\${sourceType}_\${targetType}\`;

    // Try exact match first
    if (this.templates.has(key)) {
      return this.templates.get(key)!;
    }

    // Try generic matches
    if (sourceType === ApplicationType.NODEJS_TYPESCRIPT && targetType === ApplicationType.NODEJS_TYPESCRIPT) {
      return this.templates.get('nodejs_nodejs')!;
    }

    if (sourceType === ApplicationType.PYTHON_STREAMLIT) {
      return this.templates.get('python_nodejs')!;
    }

    if (sourceType === ApplicationType.REACT_FRONTEND) {
      return this.templates.get('react_frontend')!;
    }

    return null;
  }

  renderTemplate(template: string, variables: Record<string, string>): string {
    let rendered = template;

    for (const [key, value] of Object.entries(variables)) {
      const placeholder = new RegExp(\`{{\${key}}}\`, 'g');
      rendered = rendered.replace(placeholder, value);
    }

    return rendered;
  }
}
